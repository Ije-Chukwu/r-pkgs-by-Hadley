# Data {#sec-data}

```{r, echo = FALSE}
source("common.R")
status("restructuring")
```

## Introduction

It's often useful to include data in a package.
If the primary purpose of a package is to distribute useful functions, example datasets make it easier to write excellent documentation.
These datasets can be hand-crafted to provide compelling use cases for the functions in the package.
Here are some examples of this type of package data:

-   [tidyr](https://tidyr.tidyverse.org/reference/index.html#data): `billboard` (song rankings), `who` (tuberculosis data from the World Health Organization)
-   [dplyr](https://dplyr.tidyverse.org/reference/index.html#data): `starwars` (Star Wars characters), `storms` (storm tracks)

At the other extreme, some packages exist solely for the purpose of distributing data, along with its documentation.
These are sometimes called "data packages".
A data package can be a nice way to share example data across multiple packages.
It is also a useful technique for getting relatively large, static files out of a more function-oriented package, which might require more frequent updates.
Here are some examples of data packages:

-   [nycflights13](https://nycflights13.tidyverse.org)
-   [babynames](https://github.com/hadley/babynames)

Finally, many packages benefit from having internal data that is used for internal purposes, but that is not directly exposed to the users of the package.

In this chapter we describe useful mechanisms for including data in your package.
The practical details differ depending on who needs access to the data, how often it changes, and what they will do with it:

-   If you want to store R objects and make them available to the user, put them in `data/`.
    This is the best place to put example datasets.
    All the concrete examples above for data in a package and data as a package use this mechanism.

-   If you want to store R objects for your own use as a developer, put them in `R/sysdata.rda`.
    This is the best place to put internal data that your functions need.
    <!--EXAMPLES TO USE SOMEWHERE: readr + data-raw/date-symbols.R + date_symbols, googledrive/googlesheets + data-raw/discovery-doc-prep + .endpoints & .schemas & .tidy_schemas-->

-   If you want to store data in some raw, non-R-specific form and make it available to the user, put it in `inst/extdata`.
    For example, readr and readxl each use this mechanism to provide a collection of delimited files and Excel workbooks, respectively.

-   If you want to store dynamic data that reflects the internal state of your package within a single R session, use an environment.
    This technique is not as common or well-known as those above, but can be very useful in specific situations.

-   If you want to store data persistently across R sessions, such as configuration or user-specific data, use one of the officially sanctioned locations.

## Exported data {#sec-data-data}

The most common location for package data is (surprise!) `data/`.
We recommend that each file in this directory be an `.rda` file created by `save()` containing a single R object, with the same name as the file.
The easiest way to achieve this is to use `usethis::use_data()`.

```{r, eval = FALSE}
my_pkg_data <- sample(1000)
usethis::use_data(my_pkg_data)
```

Let's imagine we are working on a package named "pkg".
The snippet above creates `data/my_pkg_data.rda` inside the source of the pkg package and adds `LazyData: true` in your `DESCRIPTION`.
This makes the `my_pkg_data` R object available to users of pkg via `pkg::my_pkg_data` or, after attaching pkg with `library(pkg)`, as `my_pkg_data`.

The snippet above is something the maintainer executes once (or every time they need to update `my_pkg_data`).
This is workflow code and should **not** appear in the `R/` directory of the source package.
(We'll talk about a suitable place to keep this code below.) For larger datasets, you may want to experiment with the compression setting, which is under the control of the `compress` argument.
The default is "bzip2", but sometimes "gzip" or "xz" can create smaller files.

It's possible to use other types of files below `data/`, but we don't recommend it because `.rda` files are already fast, small, and explicit.
The other possibilities are described in the documentation for `utils::data()` and in the [Data in packages](https://rstudio.github.io/r-manuals/r-exts/Creating-R-packages.html#data-in-packages) section of Writing R Extensions.
In terms of advice to package authors, the help topic for `data()` seems to implicitly make the same recommendations as we do above:

-   Store one R object in each `data/*.rda` file
-   Use the same name for that object and its `.rda` file
-   Use lazy-loading, by default

If the `DESCRIPTION` contains `LazyData: true`, then datasets will be lazily loaded.
This means that they won't occupy any memory until you use them.
The following example shows memory usage before and after loading the nycflights13 package.
You can see that memory usage doesn't change until you inspect the `flights` dataset stored inside the package.

```{r}
lobstr::mem_used()
library(nycflights13)
lobstr::mem_used()

invisible(flights)
lobstr::mem_used()
```

We recommend that you include `LazyData: true` in your `DESCRIPTION` if you are shipping `.rda` files below `data/`.
If you use `use_data()` to create such datasets, it will automatically make this modification to `DESCRIPTION` for you.

::: callout-warning
It is important to note that lazily-loaded datasets do **not** need to be pre-loaded with `utils::data()` and, in fact, it's usually best to avoid doing so.
Above, once we did `library(nycflights13)`, we could immediately access `flights`.
There is no call to `data(flights)`, because it is not necessary.

There are specific downsides to `data(some_pkg_data)` calls that support a policy of only using `data()` when it is actually necessary, i.e. for datasets that would not be available otherwise:

-   By default, `data(some_pkg_data)`, creates one or more objects in the user's global workspace. There is the potential to silently overwrite pre-existing objects with new values.
-   There is also no guarantee that `data(foo)` will create exactly one object named "foo". It could create more than one object and/or objects with totally different names.

One argument in favor of calls like `data(some_pkg_data, package = "pkg")` that are not strictly necessary is that it clarifies which package provides `some_pkg_data`.
We prefer alternatives that don't modify the global workspace, such as a code comment or access via `pkg::some_pkg_data`.

This excerpt from the documentation of `data()` conveys that it is largely of historical importance:

> `data()` was originally intended to allow users to load datasets from packages for use in their examples, and as such it loaded the datasets into the workspace `.GlobalEnv`.
> This avoided having large datasets in memory when not in use: that need has been almost entirely superseded by lazy-loading of datasets.
:::

### Preserve the origin story of package data {#sec-data-data-raw}

Often, the data you include in `data/` is a cleaned up version of raw data you've gathered from elsewhere.
We highly recommend taking the time to include the code used to do this in the source version of your package.
This makes it easy for you to update or reproduce your version of the data.
This data-creating script is also a natural place to leave comments about important properties of the data, i.e. which features are important for downstream usage in package documentation.

We suggest that you keep this code in one or more `.R` files below `data-raw/`.
You don't want it in the bundled version of your package, so this folder should be listed in `.Rbuildignore`.
usethis has a convenience function that can be called when you first adopt the `data-raw/` practice or when you add an additional `.R` file to the folder:

```{r, eval = FALSE}
usethis::use_data_raw()

usethis::use_data_raw("my_pkg_data")
```

`use_data_raw()` creates the `data-raw/` folder and lists it in `.Rbuildignore`.
A typical script in `data-raw/` includes code to prepare a dataset and ends with a call to `use_data()`.

These data packages all use the approach recommended here for `data-raw/`:

-   [babynames](https://github.com/hadley/babynames)
-   [nycflights13](https://github.com/hadley/nycflights13)
-   [gapminder](https://github.com/jennybc/gapminder)

::: callout-tip
## ggplot2: A cautionary tale

We have a confession to make: the origins of many of ggplot2's example datasets has been lost in the sands of time.
In the grand scheme of things, this is not a huge problem, but maintenance is certainly more pleasant when a package's assets can be reconstructed *de novo* and easily updated as necessary.
:::

::: callout-warning
## Submitting to CRAN

Generally, package data should be smaller than a megabyte - if it's larger you'll need to argue for an exemption.
This is usually easier to do if the data is in its own package and won't be updated frequently, i.e. if you approach this as a dedicated "data package".
For reference, the babynames and nycflights packages have had a release once every one to two years, since they first appeared on CRAN.

If you are bumping up against size issues, you should be intentional with regards to the method of data compression.
The default for `usethis::use_data(compress =)` is "bzip2", whereas the default for `save(compress =)` is (effectively) "gzip", and "xz" is yet another valid option.

You'll have to experiment with different compression methods and make this decision empirically.
`tools::resaveRdaFiles("data/")` automates this process, but doesn't inform you of which compression method was chosen.
You can learn this after the fact with `tools::checkRdaFiles()`.
Assuming you are keeping track of the code to generate your data, it would be wise to update the corresponding `use_data(compress =)` call below `data-raw/` and re-generate the `.rda` cleanly.
:::

### Documenting datasets {#documenting-data}

Objects in `data/` are always effectively exported (they use a slightly different mechanism than `NAMESPACE` but the details are not important).
This means that they must be documented.
Documenting data is like documenting a function with a few minor differences.
Instead of documenting the data directly, you document the name of the dataset and save it in `R/`.
For example, the roxygen2 block used to document the `who` data in tidyr is saved in `R/data.R` and looks something like this:

```{r, eval = FALSE}
#' World Health Organization TB data
#'
#' A subset of data from the World Health Organization Global Tuberculosis
#' Report ...
#'
#' @format ## `who`
#' A data frame with 7,240 rows and 60 columns:
#' \describe{
#'   \item{country}{Country name}
#'   \item{iso2, iso3}{2 & 3 letter ISO country codes}
#'   \item{year}{Year}
#'   ...
#' }
#' @source <https://www.who.int/teams/global-tuberculosis-programme/data>
"who"
```

There are two roxygen tags that are especially important for documenting datasets:

-   `@format` gives an overview of the dataset.
    For data frames, you should include a definition list that describes each variable.
    It's usually a good idea to describe variables' units here.

-   `@source` provides details of where you got the data, often a URL.

Never `@export` a data set.

### Non-ASCII characters in data

The R objects you store in `data/*.rda` often contain strings, with the most common example being character columns in a data frame.
If you can constrain these strings to only use ASCII characters, it certainly makes things simpler.
But of course, there are plenty of legitimate reasons why package data might include non-ASCII characters.

In that case, we recommend that you embrace the [UTF-8 Everywhere manifesto](http://utf8everywhere.org) and use the UTF-8 encoding.
The `DESCRIPTION` file placed by `usethis::create_package()` always includes `Encoding: UTF-8`, so by default a devtools-produced package already advertises that it will use UTF-8.

Making sure that the strings embedded in your package data have the intended encoding is something you accomplish in your data preparation code, i.e. in the R scripts below `data-raw/`.
You can use `Encoding()` to learn the current encoding of the elements in a character vector and functions such as `enc2utf8()` or `iconv()` to convert between encodings.

::: callout-warning
## Submitting to CRAN

If you have UTF-8-encoded strings in your package data, you may see this from `R CMD check`:

    -   checking contents of 'data' directory ... OK
    -   checking data for non-ASCII characters ... NOTE
        Note: found 352 marked UTF-8 strings

This `NOTE` is truly informational, i.e. it is a `NOTE` that you do not need to address or attempt to fix.
As long as you actually intend to have UTF-8 strings in your package data, all is well.

Ironically, this `NOTE` is actually suppressed by `R CMD check --as-cran`, i.e. by including the `--as-cran` flag, despite the fact that this note does appear in the check results once a package is on CRAN.
By default, `devtools::check()` sets the `--as-cran` flag and therefore does not transmit this `NOTE`.
But you can surface it with `check(cran = FALSE, env_vars = c("_R_CHECK_PACKAGE_DATASETS_SUPPRESS_NOTES_" = "false"))`.
:::

<!-- https://github.com/wch/r-source/blob/f6737799b169710006b040f72f9abc5e09180229/src/library/tools/R/QC.R#L4672 -->

If you seem to have non-ASCII strings in your package data and this is unintentional, `tools::checkRdaFiles()` can be helpful for determining which `.rda` file is the culprit.
*NO, WAIT, HOLD ON, THIS IS NOT ACTUALLY TRUE. This is not what the `ASCII` column of the return value actually means. Maybe you really do have to call `tools:::.check_package_datasets()` to figure out which file(s) to blame?*

## Internal data {#data-sysdata}

Sometimes your package functions need access to pre-computed data.
If you put these objects in `data/`, they'll also be available to package users, which is not appropriate.
Instead, you can save your package's internal data in `R/sysdata.rda`.

Here are some examples of internal package data:

-   Two colour-related packages, [munsell](https://github.com/cwickham/munsell) and [dichromat](https://cran.r-project.org/web/packages/dichromat/index.html), use `R/sysdata.rda` to store large tables of colour data.
-   [googledrive](https://github.com/tidyverse/googledrive) and [googlesheets4](https://github.com/tidyverse/googlesheets4) wrap the Google Drive and Google Sheets APIs, respectively. Both use `R/sysdata.rda` to store data derived from a so-called [Discovery Document](https://developers.google.com/discovery/v1/reference/apis) which "describes the surface of the API, how to access the API and how API requests and responses are structured".

The easiest way to create `R/sysdata.rda` is to use `usethis::use_data(internal = TRUE)`:

```{r, eval = FALSE}
internal_this <- ...
internal_that <- ...

usethis::use_data(internal_this, internal_that, internal = TRUE)
```

Unlike `data/`, where you use one `.rda` file per exported data object, you store all of your internal data objects together in the single file `R/sysdata.rda`.

Let's imagine we are working on a package named "pkg".
The snippet above creates `R/sysdata.rda` inside the source of the pkg package.
This makes the objects `internal_this` and `internal_that` available for use inside of the functions defined below `R/` and in the tests.
During interactive development, `internal_this` and `internal_that` are available after a call to `devtools::load_all()`, just like an internal function.

Much of the advice given for external data holds for internal data as well:

-   It's a good idea to store the code that generates your individual internal data objects, as well as the `use_data()` call that writes all of them into `R/sysdata.rda`. This is workflow code that belongs below `data-raw/`, not below `R/`.
-   `usethis::use_data_raw()` can be used to initiate the use of `data-raw/` or to initiate a new `.R` script there.
-   If your package is uncomfortably large, experiment with different values of `compress` in `use_data(internal = TRUE)`.

There are also key distinctions, where the handling of internal and external data differs:

-   Objects in `R/sysdata.rda` are not exported (they shouldn't be), so they don't need to be documented.
-   Usage of `R/sysdata.rda` has no impact on DESCRIPTION, i.e. the need to specify the `LazyData` field is strictly about the exported data below `data/`.

## Raw data file {#sec-data-extdata}

If you want to show examples of loading/parsing raw data, put the original files in `inst/extdata/`.
When the package is installed, all files (and folders) in `inst/` are moved up one level to the top-level directory, which is why they can't have names that conflict with standard parts of an R package, like `R/` or `DESCRIPTION` .
The files below `inst/extdata/` in the source package will be located below `extdata/` in the corresponding installed package.

The main reason to do include such files is when a key part of a package's functionality is to do something with data that is in an external file.
Examples of such packages include:

-   readr, which reads rectangular data out of delimited files
-   readxl, which reads rectangular data of of Excel spreadsheets
-   xml2, which can read XML and HTML from file
-   archive, which can read archive files, such as tar or ZIP

All of these packages have one of more example files below `inst/extdata/`.

It is also common for data packages to provide, e.g., a csv version of the package data that is also provided as an R object.
Examples of such packages include:

-   palmerpenguins: `penguins` and `penguins_raw` are also represented as `extdata/penguins.csv` and `penguins_raw.csv`
-   gapminder: `gapminder`, `continent_colors`, and `country_colors` are also represented as `gapminder.tsv`, `extdata/continent-colors.tsv`, and `extdata/country-colors.tsv`

There are two potential payoffs: First, this gives teachers and other expositors more to work with once they decide to use a specific dataset.
If you've started teaching R with `palmerpenguins::penguins` or `gapminder::gapminder` and you want to introduce data import, it can be helpful to students if their first use of a new command, like `readr::read_csv()` or `read.csv()`, is applied to a familiar dataset.
They have pre-existing intuition about the expected result.
Finally, if package data evolves over time, having a csv or other plain text representation in the source package can make it easier to what's changed.

### Filepaths

TO ADD: `fs::path_package()`

TO ADD: more about the devtools shim

To refer to files in `inst/extdata` (whether installed or not), use `system.file()`.
For example, the [readr](https://readr.tidyverse.org) package uses `inst/extdata` to store delimited files for use in examples:

```{r}
system.file("extdata", "mtcars.csv", package = "readr")
```

Beware: by default, if the file does not exist, `system.file()` does not return an error - it just returns the empty string:

```{r}
system.file("extdata", "iris.csv", package = "readr")
```

If you want to have an error message when the file does not exist, add the argument `mustWork = TRUE`:

```{r, error = TRUE}
system.file("extdata", "iris.csv", package = "readr", mustWork = TRUE)
```

### `pkg_example()` path helpers

Talks about, e.g., `readr_example()`

## Internal state

state that persists within a session

https://github.com/hadley/r-pkgs/issues/818

```{r, eval = FALSE}
the <- new.env(parent = emptyenv())
```

blog post that made me "get" the internal environment technique:\
<https://trestletech.com/2013/04/package-wide-variablescache-in-r-package/>

## Persistent user data

state that persists within a user

https://github.com/hadley/r-pkgs/issues/818

`?tools::R_user_dir()`

[rappdirs](https://rappdirs.r-lib.org)
