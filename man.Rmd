# Function documentation {#man}

```{=html}
<!--
Notes re: revision

Now that roxygen2 itself is much better documented, this can become less mechanistic.

Get into some squishier topics: How do you describe a function? How to document parameters?

Examples: how to write them, think about dependencies, running time, ways to not run certain examples that will fly at CRAN
-->
```
```{r, include = FALSE}
source("common.R")
```

Documentation is one of the most important aspects of a good package because without it, users won't know how to use your package!
Documentation is also useful for future-you (so you remember what your functions were supposed to do), and for developers extending your package.

There are multiple forms of documentation.
In this chapter, you'll learn about object documentation, as accessed by `?` or `help()`.
Function documentation is reference documentation.
It works like a dictionary: a dictionary is helpful if you want to know what a word means, it won't help you find the right word for a new situation.
Similarly, function documentation is helpful if you already know the name of the function, but it doesn't help you find the function you need to solve a given problem.
That's one of the jobs of vignettes, which you'll learn about in the next chapter.

R provides a standard way of documenting the functions in a package: you write `.Rd` files in the `man/` directory.
These files use a custom syntax, loosely based on LaTeX, and are rendered to HTML, plain text, or pdf for viewing.
We, however, are not going to write these files by hand, and instead we'll use roxygen2 to generate them from specially formatted comments.

The goal of roxygen2 is to make documenting your functions as easy as possible.
It has a number of advantages over writing `.Rd` files by hand:

-   Code and documentation are intermingled so that when you modify your code, you're reminded to also update your documentation.

-   You can write using markdown, rather than remembering the details of the `.Rd` syntax.

-   roxygen2 dynamically inspects the objects that it documents, so you can skip some boilerplate that you'd otherwise need to write by hand.

-   It abstracts over the differences in documenting different types of objects, so you need to learn fewer details.

In this chapter we'll focus on documenting functions, but the same ideas apply to documenting datasets, classes and generics, and packages.

As well as generating `.Rd` files, roxygen2 can also manage your `NAMESPACE` and the `Collate` field in `DESCRIPTION`.
This chapter discusses `.Rd` files and the collate field.
[NAMESPACE](#namespace) describes how you can use roxygen2 to manage your `NAMESPACE`, and why you should care.

## roxygen2 basics

### The documentation workflow {#man-workflow}

In this section, we'll first go over a rough outline of the complete documentation workflow.
Then, we'll dive into each step individually.
There are four basic steps:

1.  Add roxygen comments to your `.R` files.

2.  Run `devtools::document()` (or press Ctrl/Cmd + Shift + D in RStudio) to convert roxygen comments to `.Rd` files.
    (`devtools::document()` calls `roxygen2::roxygenise()` to do the hard work.)

3.  Preview documentation with `?`.

4.  Rinse and repeat until the documentation looks the way you want.

The process starts when you add roxygen comments to your source file: roxygen comments start with `#'` to distinguish them from regular comments.
Here's documentation for a simple function:

```{r}
#' Add together two numbers
#' 
#' @param x A number.
#' @param y A number.
#' @return The sum of `x` and `y`.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

Pressing Ctrl/Cmd + Shift + D (or running `devtools::document()`) will generate a `man/add.Rd` that looks like:

    % Generated by roxygen2 (7.2.0): do not edit by hand
    \name{add}
    \alias{add}
    \title{Add together two numbers}
    \usage{
    add(x, y)
    }
    \arguments{
      \item{x}{A number.}

      \item{y}{A number.}
    }
    \value{
    The sum of \code{x} and \code{y}
    }
    \description{
    Add together two numbers
    }
    \examples{
    add(1, 1)
    add(10, 1)
    }

If you're familiar with LaTeX, this should look familiar since the `.Rd` format is loosely based on it.
You can read more about the Rd format in the [R extensions](https://cran.r-project.org/doc/manuals/R-exts.html#Rd-format) manual.
Note the comment at the top of the file: it was generated by code and shouldn't be modified.
Indeed, if you use roxygen2, you'll rarely need to look at these files.

When you use `?add`, `help("add")`, or `example("add")`, R looks for an `.Rd` file containing `\alias{"add"}`.
It then parses the file, converts it into HTML and displays it.
Here's what the result looks like in RStudio:

```{r, echo = FALSE}
knitr::include_graphics("images/man-add.png")
```

(Note you can preview development documentation because devtools overrides the usual help functions to teach them how to work with source packages. If the documentation doesn't appear, make sure that you're using devtools and that you've loaded the package with `devtools::load_all()`.)

### roxygen2 comments, blocks, and tags {#roxygen-comments}

roxygen2 comments start with `#'`.
All the roxygen lines preceding a function are called a **block**.
Blocks are broken up into **tags**, which look like `@tagName details`.
The content of a tag extends from the end of the tag name to the start of the next tag (or the end of the block).
Each block includes some text before the first tag.
This is called the **introduction**, and is parsed specially, as described next.

Here's a simple example using the documentation for `stringr::str_unique()`:

```{r}
#' Remove duplicated strings
#'
#' `str_unique()` removes duplicated values, with optional control over
#' how duplication is measured.
#'
#' @param string A character vector to return unique entries.
#' @param ... Other options used to control matching behavior between duplicate
#'   strings. Passed on to [stringi::stri_opts_collator()].
#' @return A character vector.
#' @seealso [unique()], [stringi::stri_unique()] which this function wraps.
#' @examples
#' str_unique(c("a", "b", "c", "b", "a"))
#'
#' # Use ... to pass additional arguments to stri_unique()
#' str_unique(c("motley", "mötley", "pinguino", "pingüino"))
#' str_unique(c("motley", "mötley", "pinguino", "pingüino"), strength = 1)
#' @export
str_unique <- function(string, ...) {
  ...
}
```

Indent the second and subsequent lines of a tag so that when scanning the documentation it's easy to see where one tag ends and the next begins.
Tags that always span multiple lines (like `@examples`) should start on a new line and don't need to be indented.

The following sections will work through the most important tags.

## Introduction

Each block includes some text before the first tag.
This is called the **introduction**, and is parsed specially:

-   The first *sentence* becomes the title of the documentation.
    That's what you see when you look at `help(package = mypackage)` and is shown at the top of each help file.
    It's a title so it should be written in sentence case and not end in a full stop.

-   The next *paragraph* is the description: this comes first in the documentation and should briefly describe what the function does.
    It comes "above the fold" and before the arguments documentation so should be reserved for the most important details.

-   Any additional *paragraphs* go into the details: this is a (often long) section that is shown after the argument description and should go into detail about how the function works.

The following example shows what the introduction for `sum()` might look like if it had been written with roxygen.
Note that I've carefully wrapped each line of the roxygen2 to block to be less that 80 characters to match the wrapping of my code.

```{r}
#' Sum of vector elements
#' 
#' `sum` returns the sum of all the values present in its arguments.
#' 
#' This is a generic function: methods can be defined for it directly or 
#' via the [Summary] group generic. For this to work properly, the arguments
#' `...` should be unnamed, and dispatch is on the first argument.
sum <- function(..., na.rm = TRUE) {}
```

### Writing good descriptions

The goal of the description is to summarize the goal of the function, usually in under a paragraph.
This can be challenging to because the title of the function is also a very concise summary of the function.
And it's often especially hard if you've just written the function because the purpose seems so intuitively obvious it's hard to understand why anyone would need an explanation.

### Complex description

The default behavior of the introduction is designed for descriptions that are only a single paragraph.
If you want to include multiple paragraphs of text or other organisations (like a bulleted list), you can use the explicit `@description` tag.
Here's an example from the documentation of `stringr::str_like()` which mimic's the `LIKE` operator from SQL:

```{r}
#' Detect the a pattern in the same way as `SQL`'s `LIKE` operator.
#'
#' @description
#' `str_like()` follows the conventions of the SQL `LIKE` operator:
#'
#' * Must match the entire string.
#' * `_` matches a single character (like `.`).
#' * `%` matches any number of characters (like `.*`).
#' * `\%` and `\_` match literal `%` and `_`.
#' * The match is case insensitive by default.
```

You can also use explicit `@title` and `@details` tags but we don't recommend it as it adds extra noise to the docs without enabling any additional functionality.

### Multiple sections

If you have a lot of information to convey in the details, I recommend using markdown headings to break the documentation up in to sections.
A good example of this sort of documentation are the functions in pkgdown (which we'll talk about shortly).

```{r}
#' # Warning
#' Do not operate heavy machinery within 8 hours of using this function.
```

### Links and images

-   Regular markdown to link to web pages: [`https://r-project.org`](https://r-project.org) or `[The R Project](https://r-project.org)`.
-   To link to a function we slightly abuse markdown syntax: `[function()]` or `[pkg::function()]`. To link to non-function documentation just omit the `()`: `[topic]`, `[pkg::topic]()`.
-   Images need to live in ...

Useful tags

-   `@seealso` allows you to point to other useful resources, either on the web, in your package `[functioname()]`, or another package `[pkg::function()]`.

-   If you have a family of related functions where every function should link to every other function in the family, use `@family`.
    The value of `@family` should be plural.

When you start using links and images, you'll also need to use a new documentation workflow, as the workflow described above does not show images or links between topics or.
If you'd like to also see links, you can use this slower but more comprehensive workflow:

1.  Re-document you package `Cmd + Shift + D`.

2.  Build and install your package by clicking `r knitr::include_graphics("images/build-reload.png")` in the build pane or by pressing Ctrl/Cmd + Shift + B.
    This installs it in your regular library, then restarts R and reloads your package.

3.  Preview documentation with `?`.

### Documenting multiple functions in the same file

By default, each function gets its own documentation topic, but if functions are closely related it often makes sense to combine them into one topic.
For example, take `str_length()` and `str_width()` which provide two different ways of computing the size of a string.
As you can see from the description, both functions are documented together, because this makes it easy to see how they differ:

```{r}
#' The length/width of a string
#'
#' @description
#' `str_length()` returns the number of codepoints in a string. These are
#' the individual elements (which are often, but not always letters) that
#' can be extracted with [str_sub()].
#'
#' `str_width()` returns how much space the string will occupy when printed
#' in a fixed width font (i.e. when printed in the console).
#'
#' ...
str_length <- function(string) {
  ...
}
```

This works because `str_width()` uses `@rdname str_length` so that its documentation is included an in existing topic:

```{r}
#' @rdname str_length
str_width <- function(string) {
  ...
}
```

There are two ways to use `@rdname`.
You can add documentation to an existing function:

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
add <- function(x, y) x + y

#' @rdname add
times <- function(x, y) x * y
```

Or, you can create a dummy documentation file by documenting `NULL` and setting an informative `@name`.

```{r}
#' Basic arithmetic
#'
#' @param x,y numeric vectors.
#' @name arith
NULL

#' @rdname arith
add <- function(x, y) x + y

#' @rdname arith
times <- function(x, y) x * y
```

## 

## Arguments

For most functions, the bulk of your documentation effort will go towards documenting how each argument affects the output of the function.
For this purpose, you'll use the `@param` (short for parameter, a synonym of argument), which is always followed by the argument name and then a description of its action.
The description is a sentence so it should start with a capital letter and end with a full stop.

The most important job of the description should provide a succinct summary of the allowed inputs and what the parameter does.
For example, here's `stringr::str_detect()`:

```{r}
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
```

If the argument has a default value, it's a good idea to repeat it in the documentation because the function usage (which shows the default values) and the argument description are quite far apart in the docs.
For example, here's `str_flatten()`:

```{r}
#' @param collapse String to insert between each piece. Defaults to `""`.
```

If an argument has a fixed set of possible parameters, you should list them.
If they're simple, you can just list them in a sentence, like in `str_trim()`:

```{r}
#' @param side Side on which to remove whitespace: `"left"`, `"right"`, or
#'   `"both"` (the default).
```

If they need more explanation, you might use a bulleted list, as in `str_wrap()`:

```{r}
#' @param whitespace_only A boolean.
#'   * `TRUE` (the default): wrapping will only occur at whitespace.
#'   * `FALSE`: can break on any non-word character (e.g. `/`, `-`).
```

### Multiple arguments

If multiple arguments are tightly coupled, you can document them together by separating the names with commas (with no spaces).
For example, in `stringr::str_equal()` `x` and `y` are interchangeable, so they're documented together:

```{r}
#' @param x,y A pair of character vectors.
```

In `str_sub()` `start` and `end` define the range of characters to replace, and you can use just `start` if you pass in a two-column matrix.
So it makes sense to document them together:

```{r}
#' @param start,end Two integer vectors. `start` gives the position
#'   of the first character (defaults to first), `end` gives the position
#'   of the last (defaults to last character). Alternatively, pass a two-column
#'   matrix to `start`.
#'
#'   Negative values count backwards from the last character.
```

### Inheriting arguments

You can inherit argument docs from another function using `@inheritParams function_name`.
stringr uses `@inheritParams` extensively because many functions have `string` and `pattern` arguments.
So `str_detect()` documents them in detail:

```{r}
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression, as described
#'   `vignette("regular-expressions")`. Control options with [regex()].
#'
#'   Match a fixed string (i.e. by comparing only bytes), using
#'   [fixed()]. This is fast, but approximate. Generally,
#'   for matching human text, you'll want [coll()] which
#'   respects character matching rules for the specified locale.
#'
#'   Match character, word, line and sentence boundaries with
#'   [boundary()]. An empty pattern, "", is equivalent to
#'   `boundary("character")`.
```

Then the majority of the other stringr functions use `@inheritParams str_detect` to get a detailed argument description without having to copy and paste.

`@inheritParams` only inherits docs for arguments that aren't already documented, allowing you to document some and inherit others.
`str_match()` uses this to document its unusual `pattern` argument:

```{r}
#' @inheritParams str_detect
#' @param pattern Unlike other stringr functions, `str_match()` only supports
#'   regular expressions, as described `vignette("regular-expressions")`. 
#'   The pattern should contain at least one capturing group.
```

The source can be a function in the current package, via `@inheritParams function`, or another package, via `@inheritParams package::function`.

## Return value

As important as the inputs to the function is the output from the function.
The job of the `@returns`[^man-1] tag is to document the output.
Here the goal is not to describe exactly how the values are computed (which the job of the description and details), but to roughly describe the overall "shape" of the output, i.e. what sort of object it is, and if appropriate its size.
For example, if your function returns a vector you should say what type and its length, or if your function returns a data frame you should describe the names of the columns, the type of each column, and how many rows.

[^man-1]: For historical reasons, you can also use `@return`, but I think you should use `@returns` because it reads a little nicer.

The return documentation for functions in strings are mostly pretty simple, they return a some type of vector the same length as some input.
For example, take `str_like()`:

```{r}
#' @returns A logical vector the same length as `string`.
```

If your package has multiple related functions, it's useful to consistently think about what makes them difference.
For example, dplyr functions take data frames as inputs and returns data frames as outputs.
But the details of that transformation is differs so each function documents what happens to the rows, the columns, the groups, and any additional attributes.
For example, here's `dplyr::filter()`:

```{r}
#' @returns
#' An object of the same type as `.data`. The output has the following properties:
#'
#' * Rows are a subset of the input, but appear in the same order.
#' * Columns are not modified.
#' * The number of groups may be reduced (if `.preserve` is not `TRUE`).
#' * Data frame attributes are preserved.
```

It's also appropriate to describe important warnings or errors that the user might see here.
For example `readr::read_csv()`:

```{r}
#' @returns A [tibble()]. If there are parsing problems, a warning will alert you.
#'   You can retrieve the full details by calling [problems()] on your dataset.
```

::: cran
For initial CRAN submission, all functions must document their a `@return` value.
This is not required for subsequent submission, but it's good practice.
There's currently no way to enforce this (we're [working on it](https://github.com/r-lib/roxygen2/issues/1334)) which is why you'll notice some tidyverse functions lack documentation of their outputs.
:::

## Examples {#dry2}

Describing how a function works is useful, but showing how it works is often even better.
That's the purpose of the `@examples` tag, which uses executable R code to show what you can do with the function.

Use examples to show the basic operation of the function, and then to highlight any particularly important properties.
`str_detct()` starts by showing a few simple variations and then highlights are property you might easily miss from reading the docs: as well as passing a vector of strings and one pattern, you can also pass one string and vector of patterns.

```{r}
#' @examples
#' fruit <- c("apple", "banana", "pear", "pineapple")
#' str_detect(fruit, "a")
#' str_detect(fruit, "^a")
#' str_detect(fruit, "a$")
#' 
#' # Also vectorised over pattern
#' str_detect("aecfg", letters)
```

Try to stay focused on the most important features without getting into the weeds of every last edge case: if you make the examples too long, it becomes hard for the user to find the key application that they're looking for.

Bear in mind that you want examples to execute relatively quickly so users can run them, and so that when you make a website for your package it doesn't take ages to generate the documentation.

::: cran
If submitting to CRAN, examples must run in under 10 minutes.
:::

### Execution

Examples are run in four common cases:

-   Interactively using the `example()` function.
-   R CMD check on a computer you control (e.g. your development machine and your CI/CD server).
-   R CMD check on a computer you don't control (e.g. CRAN).
-   When building your pkgdown website

This means that you example code must run without error in all three cases.
This means that the code must be self-contained, and only uses packages that are listed in the `DESCRIPTION` fields `Imports` and `Suggests`.

### Things to avoid

There are a few constraints imposed by CRAN on examples because if a user runs the example interactively with `example()` you don't want to mess up their current session.
This means that you shouldn't make changes to the global state, so:

-   Don't change global options with `options()` and don't mess with the working directory.
-   Don't create create files in the current working directory. Instead write them to a temporary directory, and make sure to clean them up at the end of the example.
-   Don't write to the clipboard.
-   Avoid depending on external resources that might occasionally fail.

### Errors

So what can you do if you want to include code that causes an error for the purposes of teaching.
There are two basic options:

-   You can wrap the code in `try()` so that the error is shown, but doesn't stop execution of the error.
-   You can wrap the code `\dontrun{}`[^man-2] so it is never run by `example()`.

[^man-2]: You used to be able to use `\donttest{}` for a similar purpose, but we no longer recommended it because CRAN sets a special flag that causes it to be executed.

### Conditional execution

In other cases, you might want code to run only in specific scenarios.
In the most common case, you don't want to run code on CRAN because you're doing something that is usually best avoided (see below) or your examples need other setup that CRAN won't have.
In this case you can use `@examplesIf` instead of `@examples`.
The code in an `@examplesIf` block will only be executed if some condition is `TRUE`:

```{r}
#' @examplesIf some_function()
#' some_other_function()
#' some_more_functions()
```

For example, googledrive uses `@examplesIf` in almost every function because the examples can only work if you have an active, authenticated, connection to googledrive as judged by `googledrive::drive_has_token()`.
For example, here's `googledrive::drive_publish()`:

```{r}
#' @examplesIf drive_has_token()
#' # Create a file to publish
#' file <- drive_example_remote("chicken_sheet") %>%
#'   drive_cp()
#'
#' # Publish file
#' file <- drive_publish(file)
#' file$published
```

::: cran
For initial CRAN submission of your package, all functions must contain some runnable examples (i.e. there must be examples and they must not all be wrapped in `\dontrun{}`).
:::

## Sharing documentation

There is a tension between the DRY (don't repeat yourself) principle of programming and the need for documentation to be self-contained.
It's frustrating to have to navigate through multiple help files in order to pull together all the pieces you need.
roxygen2 provides a number of ways to avoid you having to repeat yourself as a developer, while not forcing the user to follow a spiderweb of links to find everything they need.
Here we'll focus on two:

-   Sharing documentation across functions with `@inherit`.

-   Combining the documentation for multiple related functions into one topics with `@describeIn` or `@rdname`.

There are also two markdown features that are useful in more complex situations:

-   You can use child documents to share `Rmd` between topics.
-   You can use inline R code to generate documentation.

### 
