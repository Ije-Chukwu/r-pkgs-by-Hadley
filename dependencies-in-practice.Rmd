# Dependencies: In Practice {#sec-dependencies-in-practice}

```{r, echo = FALSE}
source("common.R")
status("restructuring")
```

## Introduction

This chapter presents the practical details of working with your dependencies inside your package.
If you need a refresher on any of the background:

-   @sec-description covers the DESCRIPTION file.
    Listing a dependency in that file, such as in Imports, is a necessary first step when taking a dependency.

-   @sec-dependencies-pros-cons provides a decision-making framework for dependencies.

-   The technical details of package namespaces, the search path, and attaching vs. loading are laid out in @sec-dependencies-namespace, @sec-dependencies-search, and @sec-dependencies-attach-vs-load.

We're finally ready to talk about how to use different types of dependencies within the different parts of your package.

## Confusion about `Imports`

First, we want to tackle a common source of confusion:

> Listing a package in `Imports` in `DESCRIPTION` has nothing to do with "importing" that package.

This is just an unfortunate choice of name for the `Imports` field.
The `Imports` field makes sure that a certain set of packages is installed when your package is installed.
It does not make those functions available to you, e.g. below `R/`, or to your user.

It is neither automatic nor necessarily advisable that a package listed in `Imports` also appears in `NAMESPACE` via `imports()` or `importFrom()`.
It is common for a package to be listed in `Imports` in `DESCRIPTION`, but not in `NAMESPACE`.
The converse is not true.
Every package mentioned in `NAMESPACE` must also be present in the `Imports` or `Depends` fields.

## Conventions for this chapter

Sometimes we can feature real functions from real packages in our examples.
But if we need to talk about a generic package or function, here are the conventions we use below:

-   pkg: the name of your hypothetical package

-   aaapkg: the name of a hypothetical dependency of your package

-   `aaa_fun()`: the name of a function provided by aaapkg

## Package is listed in `Imports`

Consider a dependency that is listed in `DESCRIPTION` in `Imports`:

``` yaml
Imports:
    aaapkg
```

The code inside your package can assume that aaapkg is installed on the system.

### In code below R/

Usually you should call functions in aaapkg explicitly using `::`, like this:

```{r}
#| eval: false
somefunction <- function(...) {
  ...
  x <- aaapkg::aaa_fun(...)
  ...
}
```

Specifically, we recommend that you default to *not* importing anything from aaapkg into your namespace.
The basic rationale is to do the most minimal and hygienic thing.

Of course there are reasons to make exceptions to this rule and to import something from another package into yours:

-   An operator: You can't call an operator from another package via `::`, so you must import it.
    Example: the null-coalescing operator from `%||%` from rlang or the original pipe from magrittr `%>%`.

-   A function that you use *a lot*: If importing a function makes your code much more readable, that's a good enough reason to import it.
    This literally reduces the number of characters required to call the external function.
    This can be especially handy when generating user-facing messages, because it makes it more likely that lines in the source correspond to lines in the output.

-   A function that you call in a tight loop: blah blah

A handy function for your interactive workflow is `usethis::use_import_from()`:

```{r}
#| eval: false
usethis::use_import_from("magrittr", "%>%")
usethis::use_import_from("glue", "glue_collapse")
```

The calls above write these roxygen tags into the source code of your package:

```{r}
#| eval: false
#' @importFrom magrittr %>%
#' @importFrom glue glue_collapse
```

Where should these roxygen tags go?
There are two ways to play this:

-   As close as possible to the usage of the external function.
    With this mindset, you would place `@importFrom` in the roxygen comment above the function in your package where you use the external function.
    If this is your style, you'll have to do it by hand.
    (This starts to break down once you use the external function in multiple places.)

-   In a central location.
    This approach keeps all `@importFrom` tags together, in a dedicated section of the package-level documentation file (which can be created with `usethis::use_package_doc()`).
    This is what `use_import_from()` implements.
    So, in `R/pkg-package.R`, you'll have something like this:

    ```{r}
    # The following block is used by usethis to automatically manage
    # roxygen namespace tags. Modify with care!
    ## usethis namespace: start
    #' @importFrom magrittr %>%
    #' @importFrom glue glue_collapse
    ## usethis namespace: end
    NULL
    ```

Recall that `devtools::document()` processes your roxygen comments, which writes help topics to `man/*.Rd` and, relevant to our current goal, generates the `NAMESPACE` file.
If you use `use_import_from()`, it does this for you and also calls `load_all()`, making the newly imported function available in your current session.

The roxygen tags above cause these directives to appear in the `NAMESPACE` file:

    importFrom(magrittr, "%>%")
    importFrom(glue, glue_collapse)

Now you can use the imported operator or function directly in your code:

```{r}
#| eval: false
somefunction <- function(...) {
  ...
  x <- ... %>%
    glue_collapse()
  ...
}
```

Sometimes you make such heavy use of so many functions from another package that you want to import its entire namespace.
This should be relatively rare.
In the tidyverse, the package we most commonly treat this way is rlang, which functions almost like a base package for us.

Here is the roxygen tag that imports all of rlang.
This should appear somewhere in `R/*.R`, such as the dedicated space described above for collecting all of your namespace import tags.

```{r}
#| eval: false
#' @import rlang
```

After calling `devtools::document()`, this roxygen tag causes this directive to appear in the `NAMESPACE` file:

    import(rlang)

This is the least recommended solution because it can make your code harder to read (you can't tell where a function is coming from), and if you `@import` many packages, it increases the chance of function name conflicts.

#### How to *not* use a package in Imports

<https://github.com/hadley/r-pkgs/issues/828>

### In test code

Refer to external functions in your tests just as you refer to them in the code below `R/`.
Usually this means you should use `aaapkg::aaa_fun()`.
But if you have imported a particular function, either specifically or as part of an entire namespace, you can just call it directly.

It's generally a bad idea to use `library()` to attach one of your dependencies somewhere in your tests, because it makes the search path situation in your tests different from how your package works "in production".
This is covered in more detail in @sec-testing-design-tension.

### In examples and vignettes

If you use a package that appears in `Imports` in one of your examples or vignettes, you'll need to either attach the package with `library(aaapkg)` or use a `aaapkg::aaa_fun()`-style call.
You can assume that aaapkg is available, because that's what `Imports` guarantees.

## Package is listed in `Suggests` {#sec-imports}

Consider a dependency that is listed in `DESCRIPTION` in `Suggests`:

``` yaml
Suggests:
    aaapkg
```

The code inside your package can NOT assume that aaapkg is installed on the system.
That will depend on how your package was installed.
Most of the functions that are used to install packages support a `dependencies` argument that controls whether to install just the hard dependencies or to take a more expansive approach:

```{r}
#| eval: false
install.packages(dependencies =)
remotes::install_github(dependencies =)
pak::pkg_install(dependencies =)
```

Broadly speaking, the default is to not install packages in `Suggests`.

### In code below R/

Inside a function in your own package, check for the availability of a suggested package with `requireNamespace("pkg", quietly = TRUE)`.
There are two basic scenarios:

```{r}
# the suggested package is required 
my_fun <- function(a, b) {
  if (!requireNamespace("aaapkg", quietly = TRUE)) {
    stop(
      "Package \"aaapkg\" must be installed to use this function.",
      call. = FALSE
    )
  }
  # code that includes calls such as aaapkg::aaa_fun()
}

# the suggested package is optional; a fallback method is available
my_fun <- function(a, b) {
  if (requireNamespace("aaapkg", quietly = TRUE)) {
    aaapkg::aaa_fun()
  } else {
    g()
  }
}
```

The rlang package has some useful functions for checking package availability.
Here's how the checks around a suggested package could look if you use rlang:

```{r}
# the suggested package is required 
my_fun <- function(a, b) {
  rlang::check_installed("aaapkg", reason = "to use `aaa_fun()`")
  # code that includes calls such as aaapkg::aaa_fun()
}

# the suggested package is optional; a fallback method is available
my_fun <- function(a, b) {
  if (rlang::is_installed("aaapkg")) {
    aaapkg::aaa_fun()
  } else {
    g()
  }
}
```

These rlang functions have handy features for programming, such as vectorization over `pkg`, classed errors with a data payload, and, for `check_installed()`, an offer to install the needed package in an interactive session.

### In test code

The tidyverse team generally writes tests as if all suggested packages are available.
That is, we use them unconditionally in the tests.

The motivation for this posture is self-consistency and pragmatism.
The key package needed to run tests is testthat and it appears in `Suggests`, not in `Imports` or `Depends`.
Therefore, if the tests are actually executing, that implies that an expansive notion of package dependencies has been applied.

Also, empirically, in every important scenario of running `R CMD check`, the suggested packages are installed.
This is generally true for CRAN and we ensure that it's true in our own automated checks.
However, it's important to note that other package maintainers take a different stance and choose to protect all usage of suggested packages in their tests and vignettes.

Sometimes even the tidyverse team makes an exception and guards the use of a suggested package in a test.
Here's a test from ggplot2, which uses `testthat::skip_if_not_installed()` to skip execution if the suggested sf package is not available.

```{r eval = FALSE}
test_that("basic plot builds without error", {
  skip_if_not_installed("sf")

  nc_tiny_coords <- matrix(
    c(-81.473, -81.741, -81.67, -81.345, -81.266, -81.24, -81.473,
      36.234, 36.392, 36.59, 36.573, 36.437, 36.365, 36.234),
    ncol = 2
  )

  nc <- sf::st_as_sf(
    data_frame(
      NAME = "ashe",
      geometry = sf::st_sfc(sf::st_polygon(list(nc_tiny_coords)), crs = 4326)
    )
  )

  expect_doppelganger("sf-polygons", ggplot(nc) + geom_sf() + coord_sf())
})
```

What might justify the use of `skip_if_not_installed()`?
In this case, the sf package can be nontrivial to install and it is conceivable that a contributor would want to run the remaining tests, even if sf is not available.

Finally, note that `testthat::skip_if_not_installed(pkg, minimum_version = "x.y.z")` can be used to conditionally skip a test based on the version of the other package.

### In examples and vignettes

Another common place to use a suggested package is in an example and here we often guard with `require()` (but you'll also see `requireNamespace()` used for this).
This example is from `ggplot2::coord_map()`.

```{r}
#| eval: false
#' @examples
#' if (require("maps")) {
#'   nz <- map_data("nz")
#'   # Prepare a map of NZ
#'   nzmap <- ggplot(nz, aes(x = long, y = lat, group = group)) +
#'     geom_polygon(fill = "white", colour = "black")
#'  
#'   # Plot it in cartesian coordinates
#'   nzmap
#' }
```

An example is basically the only place where we would use `require()` inside a package.
Read more in @sec-dependencies-attach-vs-load.

Our stance regarding the use of suggested packages in vignettes is similar to that for tests.
The key package needed to build vignettes (rmarkdown and knitr) are listed in Suggests.
Therefore, if the vignettes are being built, it's reasonable to assume that all of the suggested packages are available.
We typically use suggested packages unconditionally inside vignettes.

But if you choose to use suggested packages conditionally in your vignettes, the knitr chunk option `eval` is very useful for achieving this.
See @sec-vignettes-eval-option for more.

## Exports {#exports}

STUFF BELOW HERE NOT REVISED YET!

For a function to be usable outside of your package, you must **export** it.
When you create a new package with `usethis::create_package()`, nothing is exported at first.
You can still experiment interactively with `load_all()` (since that loads all functions, not just those that are exported).
But if you install and reload the package, you'll notice that no functions are available.

In the devtools workflow and this book, the NAMESPACE file is automatically generated from special roxygen comments in the R/\*.R files.

To export an object, put `@export` in its roxygen block.
For example:

```{r}
#' @export
foo <- function(x, y, z) {
  ...
}
```

This will then generate `export()`, `exportMethods()`, `exportClass()` or `S3method()` depending on the type of the object.

You export functions that you want other people to use.
Exported functions must be documented, and you must be cautious when changing their interface --- other people are using them!
Generally, it's better to export too little than too much.
It's easy to export things that you didn't before; it's hard to stop exporting a function because it might break existing code.
Always err on the side of caution, and simplicity.
It's easier to give people more functionality than it is to take away stuff they're used to.

I believe that packages that have a wide audience should strive to do one thing and do it well.
All functions in a package should be related to a single problem (or a set of closely related problems).
Any functions not related to that purpose should not be exported.
For example, most of my packages have a `utils.R` file that contains many small functions that are useful for me, but aren't part of the core purpose of those packages.
I never export these functions.

```{r}
# Defaults for NULL values
`%||%` <- function(a, b) if (is.null(a)) b else a

# Remove NULLs from a list
compact <- function(x) {
  x[!vapply(x, is.null, logical(1))]
}
```

That said, if you're creating a package for yourself, it's far less important to be so disciplined.
Because you know what's in your package, it's fine to have a local "misc" package that contains a passel of functions that you find useful.
But I don't think you should release such a package.

The following sections describe what you should export if you're using S3, S4 or RC.
NOT CURRENTLY TRUE!

https://github.com/hadley/r-pkgs/issues/576 how and why to re-export a function

### Workflow {#namespace-workflow}

Generating the namespace with roxygen2 is just like generating function documentation with roxygen2.
You use roxygen2 blocks (starting with `#'`) and tags (starting with `@`).
The workflow is the same:

1.  Add roxygen comments to your `.R` files.

2.  Run `devtools::document()` (or press Ctrl/Cmd + Shift + D in RStudio) to convert roxygen comments to `.Rd` files.

3.  Look at `NAMESPACE` and run tests to check that the specification is correct.

4.  Rinse and repeat until the correct functions are exported.

## Stuff yet to be placed

-   in your functions, below R/
-   in your tests, below tests/
-   in your help topics, below man/
-   in your vignettes and articles, below vignettes/

`Depends` is just a convenience for the user: if your package is attached, it also attaches all packages listed in `Depends`.
If your package is loaded, packages in `Depends` are loaded, but not attached, so you need to qualify function names with `::` or specifically import them.

https://github.com/hadley/r-pkgs/issues/447 .onLoad(), .onAttach() what they are and advice to not touch the random number generator there

https://github.com/hadley/r-pkgs/issues/485 why you don't want Depends

https://github.com/hadley/r-pkgs/issues/657 Decide what's happening with S3, S4, R6, R7

### Nonstandard dependencies

In packages developed with devtools, you may see `DESCRIPTION` files that use a couple other nonstandard fields for package dependencies specific to development tasks.

The `Remotes` field can be used when you need to install a dependency from a nonstandard place, i.e. from somewhere besides CRAN or Bioconductor.
One common example of this is when you're developing against a development version of one of your dependencies.
During this time, you'll want to install the dependency from its development repository, which is often GitHub.
The way to specify various remote sources is described in a [devtools vignette](https://devtools.r-lib.org/articles/dependencies.html).

<!-- TODO: long-term, a better link will presumably be https://pak.r-lib.org/reference/pak_package_sources.html, once the pivot from remotes to pak is further along. -->

The dependency and any minimum version requirement still need to be declared in the normal way in, e.g., `Imports`.
`usethis::use_dev_package()` helps to make the necessary changes in `DESCRIPTION`.
If your package temporarily relies on a development version of usethis, the affected `DESCRIPTION` fields might evolve like this:

<!-- This is unlovely, but I just wanted to get the content down "on paper". It's easier to convey with a concrete example. -->

    Stable -->               Dev -->                       Stable again
    ----------------------   ---------------------------   ----------------------
    Package: yourpkg         Package: yourpkg              Package: yourpkg
    Version: 1.0.0           Version: 1.0.0.9000           Version: 1.1.0
    Imports:                 Imports:                      Imports: 
        usethis (>= 2.1.3)       usethis (>= 2.1.3.9000)       usethis (>= 2.2.0)
                             Remotes:   
                                 r-lib/usethis 

It's important to note that you should not submit your package to CRAN in the intermediate state, meaning with a `Remotes` field and with a dependency required at a version that's not available from CRAN or Bioconductor.
For CRAN packages, this can only be a temporary development state, eventually resolved when the dependency updates on CRAN and you can bump your minimum version accordingly.

You may also see devtools-developed packages with packages listed in `DESCRIPTION` fields in the form of `Config/Needs/*`.
This pattern takes advantage of the fact that fields prefixed with `Config/` are ignored by CRAN and also do not trigger a NOTE about "Unknown, possibly mis-spelled, fields in `DESCRIPTION`".

```{=html}
<!--
https://github.com/wch/r-source/blob/de49776d9fe54cb4580fbbd04906b40fe2f6117e/src/library/tools/R/QC.R#L7133
https://github.com/wch/r-source/blob/efacf56dcf2f880b9db8eafa28d49a08d56e861e/src/library/tools/R/utils.R#L1316-L1389
-->
```
The use of `Config/Needs/*` is not directly related to devtools.
It's more accurate to say that it's associated with continuous integration workflows made available to the community at <https://github.com/r-lib/actions/> and exposed via functions such as `usethis::use_github_actions()`.
A `Config/Needs/*` field tells the [`setup-r-dependencies`](https://github.com/r-lib/actions/tree/master/setup-r-dependencies#readme) GitHub Action about extra packages that need to be installed.

`Config/Needs/website` is the most common and it provides a place to specify packages that aren't a formal dependency, but that must be present in order to build the package's website.
On the left is an example of what might appear in `DESCRIPTION` for a package that uses various tidyverse packages in the non-vignette articles on its website, which is also formatted with styling that lives in the `tidyverse/template` GitHub repo.
On the right is the corresponding excerpt from the configuration of the workflow that builds and deploys the website.

    in DESCRIPTION                  in .github/workflows/pkgdown.yaml
    --------------------------      ---------------------------------
    Config/Needs/website:           - uses: r-lib/actions/setup-r-dependencies@v1
        tidyverse,                    with:
        tidyverse/tidytemplate          extra-packages: pkgdown
                                        needs: website

Continuous integration and package websites are discussed more in ??
and ??,
respectively.
*These chapters are a yet-to-be-(re)written task for the 2nd edition.*

<!-- TODO: Link to CI and pkgdown material when it has been written and/or revised. -->

The `Config/Needs/*` convention is handy because it allows a developer to use `DESCRIPTION` as their definitive record of package dependencies, while maintaining a clean distinction between true runtime dependencies versus those that are only needed for specialized development tasks.

<!-- re: describing different types of dependencies, another term you see for "runtime" dependency is "production" -->
